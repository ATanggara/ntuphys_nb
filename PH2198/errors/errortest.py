from scipy import *

## Input data (generated by a simulation with random noise).
L  = array([0.10, 0.16, 0.22, 0.28, 0.34, 0.40, 0.46, 0.52, 0.58, 0.64])
T  = array([0.71, 0.76, 0.91, 1.00, 1.20, 1.14, 1.44, 1.40, 1.53, 1.58])
dT = array([0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05])

Tsq = T*T
Tsq_error = 2*T*dT

## Fit L and Tsq to a first-order polynomial
degree  = 1
weights = 1/Tsq_error
est, covar = polyfit(L, Tsq, degree, w=weights, cov=True)

## Estimators and their errors:
a  = est[0]               # Estimate of a
b  = est[1]               # Estimate of b
da = sqrt(covar[0,0])     # Standard error of a
db = sqrt(covar[1,1])     # Standard error of b

print(a)
print(b)
print(da)
print(db)


## Compute the estimate of g
g  = 4*pi*pi/a
dg = (g/a)*da

## Plot the data points and fitted curve
import matplotlib.pyplot as plt
plt.figure(figsize=(8,4))
plt.errorbar(L, Tsq, yerr=Tsq_error, fmt='o')
plt.xlabel('L (m)', fontsize=12)
plt.ylabel('T^2 (s^2)', fontsize=12)
## State the fitted value of g in the figure
text = "g = " + "{:.1f}".format(g) + " +/- " + "{:.1f}".format(dg) + " m/s^2"
plt.title(text, fontsize=12)
## Plot the fitted curve
L2 = linspace(0, 0.7, 100)
plt.plot(L2, a*L2+b)
plt.show()
